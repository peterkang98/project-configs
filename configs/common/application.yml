management:
  endpoints:
    web:
      exposure:
        include: refresh,health,info,prometheus,metrics
  zipkin:
    tracing:
      endpoint: "http://localhost:9411/api/v2/spans" # Zipkin 수집 서버의 엔드포인트 URL을 입력합니다.
  tracing:
    sampling:
      probability: 1.0
  endpoint:
    prometheus:
      enabled: true
    metrics:
      enabled: true
      export:
        prometheus:
          enabled: true
      tags:
        application: ${spring.application.name}


spring:
  cloud:
    loadbalancer:
      ribbon:
        enabled: false # Netflix Ribbon 대신 Spring Cloud LoadBalancer 사용
    circuitbreaker:
      resilience4j:
        enabled: true  # Resilience4j 회로 차단기 활성화

        # 공통 템플릿(모든 인스턴스의 기본 값)
        configs:
          default: # 기본 회로 차단기 설정
            slidingWindowType: COUNT_BASED  # 호출 횟수 기반으로 슬라이딩 윈도우 설정 (TIME_BASED도 가능)
            slidingWindowSize: 5  # 상태 결정을 위해 고려할 최근 호출 수
            minimumNumberOfCalls: 1  # 회로 차단기가 결정을 내리기 위한 최소 호출 수
            permittedNumberOfCallsInHalfOpenState: 2  # 반개방 상태에서 허용되는 호출 수
            failureRateThreshold: 50  # 실패율이 50%를 초과하면 회로 차단 (% 기준)
            waitDurationInOpenState: 5s  # 회로가 열린 상태로 유지되는 시간 (30초)
            recordExceptions: # 실패로 간주할 예외 목록
              - java.lang.RuntimeException
              - org.springframework.web.client.HttpServerErrorException

        # 서비스/클라이언트별 오버라이드
        instances:
          externalService: # 'externalService'라는 이름의 회로 차단기 인스턴스
            baseConfig: default  # 위에서 정의한 기본 설정 상속
            failureRateThreshold: 40  # 기본 설정 오버라이드: 40%로 임계값 낮춤
            waitDurationInOpenState: 20s  # 기본 설정 오버라이드: 20초로 대기 시간 단축
  rabbitmq:
    host: localhost                 # RabbitMQ 브로커의 호스트명 또는 IP. 로컬 테스트 시 'localhost' 사용.
    port: 5672                      # AMQP 포트(기본 5672). 브로커가 다른 포트를 쓰면 해당 포트로 설정.
    username: ${RABBITMQ_USERNAME}
    password: ${RABBITMQ_PASSWORD}
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: "http://localhost:3300/realms/earlyexpress"
      client:
        registration:
          keycloak:
            client-id: ${KEYCLOAK_CLIENT_ID}
            client-secret: ${KEYCLOAK_CLIENT_SECRET}
            authorization-grant-type: authorization_code
            redirect-uri: "http://localhost:3000/v1/user/authorization/code"
            scope:
              - openid
              - profile
              - email
        provider:
          keycloak:
            issuer-uri: "http://localhost:3000/v1/user/authorization/code"

keycloak:
  server-url: http://localhost:3300
  realm: earlyexpress
  client-id: ${KEYCLOAK_CLIENT_ID}
  client-secret: ${KEYCLOAK_CLIENT_SECRET}
  admin-username: ${KEYCLOAK_ADMIN_USERNAME}
  admin-password: ${KEYCLOAK_ADMIN_PASSWORD}

resilience4j:
  retry:  # 재시도 설정
    configs:
      default:  # 기본 재시도 설정
        maxAttempts: 3  # 최대 3회 재시도
        waitDuration: 1s  # 재시도 간 1초 대기
        enableExponentialBackoff: true  # 지수 백오프 활성화 (재시도마다 대기 시간 증가)
        exponentialBackoffMultiplier: 2.0  # 각 재시도마다 대기 시간이 2배로 증가
        retryExceptions:  # 재시도할 예외 목록
          - java.lang.RuntimeException
    instances:
      externalService:  # 'externalService'라는 이름의 재시도 인스턴스
        baseConfig: default  # 기본 설정 상속
        maxAttempts: 2  # 기본 설정 오버라이드: 최대 2회만 재시도
        waitDuration: 500ms  # 기본 설정 오버라이드: 대기 시간 500ms로 단축

  bulkhead:  # 벌크헤드 설정 (동시 호출 제한)
    configs:
      default:  # 기본 벌크헤드 설정
        type: THREADPOOL  # 스레드풀 타입 벌크헤드 사용 (SEMAPHORE 대신)
        coreThreadPoolSize: 5  # 스레드풀의 기본 스레드 수 (항상 활성 상태로 유지)
        maxThreadPoolSize: 10  # 스레드풀의 최대 스레드 수 (부하 증가 시 확장)
        queueCapacity: 50  # 모든 스레드가 사용 중일 때 대기할 수 있는 요청 수


  ratelimiter:  # 속도 제한 설정
    configs:
      default:  # 기본 속도 제한 설정
        limitForPeriod: 50  # 주기당 최대 50개 요청 허용
        limitRefreshPeriod: 1s  # 제한이 1초마다 초기화됨
        timeoutDuration: 0ms  # 허가 대기 시간 (0ms는 대기 없이 즉시 거부)
    instances:
      externalService:  # 'externalService'라는 이름의 속도 제한 인스턴스
        baseConfig: default  # 기본 설정 상속
        limitForPeriod: 20  # 기본 설정 오버라이드: 주기당 20개로 제한
        limitRefreshPeriod: 1s  # 1초 주기 유지

feign:
  client:
    config:
      default:
        connectTimeout: 5000
        readTimeout: 5000
        loggerLevel: FULL